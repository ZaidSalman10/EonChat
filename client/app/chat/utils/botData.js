// client/app/chat/utils/botData.js
export const EON_KNOWLEDGE = {
  "start": {
    keywords: ["hello", "hi", "help", "who", "start", "begin", "intro"],
    text: "üöÄ **Welcome to EonChat DSA Kernel** üöÄ\n\nI'm your **Advanced DSA Architect Bot**. I have deep knowledge of:\n\n‚Ä¢ **Data Structures:** Stacks, Queues, Linked Lists, Trees (BST, Trie, Heaps), Graphs, HashMaps\n‚Ä¢ **Algorithms:** BFS, DFS, Sorting, Dynamic Programming, Greedy\n‚Ä¢ **System Architecture:** Real-time messaging, caching, optimization\n‚Ä¢ **Performance:** Time/Space complexity analysis\n\nWhat would you like to explore?",
    options: ["Data Structures Overview", "Algorithms Overview", "EonChat Architecture", "Performance Analysis"]
  },

  // ============ DATA STRUCTURES ============
  "data_structures": {
    keywords: ["data structure", "structures", "overview", "types"],
    text: "üìä **EonChat's Data Structure Arsenal**\n\nWe employ a multi-layered architecture:\n\n**Linear Structures:**\n‚Ä¢ Stacks ‚Üí Notifications (LIFO)\n‚Ä¢ Queues ‚Üí Message delivery (FIFO)\n‚Ä¢ Linked Lists ‚Üí Chat history\n\n**Tree Structures:**\n‚Ä¢ BST ‚Üí Activity analytics\n‚Ä¢ Trie ‚Üí Keyword matching & autocomplete\n‚Ä¢ Min-Heap ‚Üí Priority message delivery\n\n**Non-Linear:**\n‚Ä¢ Graph ‚Üí Social network\n‚Ä¢ HashMap ‚Üí O(1) lookups everywhere\n\nWhich structure interests you?",
    options: ["Linear Structures", "Tree Structures", "Graph & HashMap", "Back to Start"]
  },

  "linear_structures": {
    keywords: ["linear", "stack", "queue", "list"],
    text: "üìè **Linear Data Structures in EonChat**\n\n**1. Stack (LIFO):**\n‚Ä¢ Notifications panel\n‚Ä¢ Undo/Redo operations\n‚Ä¢ Browser history tracking\n\n**2. Queue (FIFO):**\n‚Ä¢ Message delivery pipeline\n‚Ä¢ Typing indicator buffer\n‚Ä¢ Event processing queue\n\n**3. Doubly Linked List:**\n‚Ä¢ Chat message history (bidirectional scroll)\n‚Ä¢ Allows O(1) insert/delete at both ends\n‚Ä¢ Memory efficient for dynamic data\n\nDive deeper into any?",
    options: ["Stack Deep Dive", "Queue Deep Dive", "Linked List Deep Dive", "Back"]
  },

  "stacks": {
    keywords: ["stack", "lifo", "pop", "push", "notification"],
    text: "üìö **Stack Implementation in EonChat**\n\n**Architecture:**\n```\nclass NotificationStack {\n  constructor() {\n    this.items = [];\n    this.top = -1;\n  }\n  \n  push(notification) { // O(1)\n    this.items[++this.top] = notification;\n  }\n  \n  pop() { // O(1)\n    return this.top >= 0 ? this.items[this.top--] : null;\n  }\n  \n  peek() { return this.items[this.top]; }\n}\n```\n\n**Use Cases:**\n‚Ä¢ Friend request stack (newest on top)\n‚Ä¢ Notification dismissal\n‚Ä¢ Navigation history\n‚Ä¢ Modal/Dialog management\n\n**Complexity:** All operations O(1)\n**Space:** O(n) where n = number of items",
    options: ["Queues", "Linked Lists", "Real-world Example", "Back"]
  },

  "queues": {
    keywords: ["queue", "fifo", "enqueue", "dequeue", "message"],
    text: "üéØ **Queue Systems in EonChat**\n\n**Priority Queue (Min-Heap):**\n```\nclass MessageQueue {\n  constructor() {\n    this.heap = [];\n  }\n  \n  enqueue(msg, priority) { // O(log n)\n    this.heap.push({msg, priority});\n    this.heapifyUp();\n  }\n  \n  dequeue() { // O(log n)\n    const msg = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this.heapifyDown();\n    return msg;\n  }\n}\n```\n\n**Applications:**\n1. **Message Delivery:** FIFO for fairness\n2. **Priority Messages:** Admin/urgent messages first\n3. **Typing Indicators:** Debounced event queue\n4. **Connection Retry:** Exponential backoff queue\n\n**Optimization:** Circular queue to prevent array shifts",
    options: ["Priority Queue Algorithm", "Message Delivery Flow", "Back"]
  },

  "linked_lists": {
    keywords: ["linked list", "node", "pointer", "chat history"],
    text: "üîó **Linked List Architecture**\n\n**Doubly Linked List for Chat:**\n```\nclass MessageNode {\n  constructor(data) {\n    this.data = data;\n    this.prev = null;\n    this.next = null;\n    this.timestamp = Date.now();\n  }\n}\n\nclass ChatHistory {\n  insert(message) { // O(1) at head/tail\n    const node = new MessageNode(message);\n    node.next = this.head;\n    if (this.head) this.head.prev = node;\n    this.head = node;\n  }\n  \n  delete(node) { // O(1) with reference\n    if (node.prev) node.prev.next = node.next;\n    if (node.next) node.next.prev = node.prev;\n  }\n}\n```\n\n**Why Doubly Linked?**\n‚Ä¢ Bidirectional scrolling (infinite scroll)\n‚Ä¢ O(1) deletion with node reference\n‚Ä¢ Efficient memory for real-time updates\n\n**Vs Array:** No reallocation, better for frequent inserts",
    options: ["Skip List Optimization", "Memory Management", "Back"]
  },

  "tree_structures": {
    keywords: ["tree", "bst", "trie", "heap"],
    text: "üå≥ **Tree Structures in EonChat**\n\n**Binary Search Tree (BST):**\n‚Ä¢ Activity analytics (sorted by time)\n‚Ä¢ User leaderboards\n‚Ä¢ O(log n) search/insert\n\n**Trie (Prefix Tree):**\n‚Ä¢ Keyword matching (this bot!)\n‚Ä¢ Autocomplete suggestions\n‚Ä¢ User search\n\n**Min-Heap:**\n‚Ä¢ Priority message queue\n‚Ä¢ Top K active users\n\n**B-Tree (Database):**\n‚Ä¢ Message indexing in MongoDB\n‚Ä¢ Optimized for disk I/O\n\nExplore which tree?",
    options: ["BST Deep Dive", "Trie Deep Dive", "Heap Implementation", "Back"]
  },

  "bst": {
    keywords: ["bst", "binary search tree", "activity", "analytics"],
    text: "üîç **Binary Search Tree - Activity Analyzer**\n\n**Structure:**\n```\nclass ActivityNode {\n  constructor(hour, count) {\n    this.hour = hour;    // 0-23\n    this.count = count;  // message count\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass ActivityBST {\n  insert(hour) { // O(log n) average\n    // Insert hour with count++\n  }\n  \n  inOrderTraversal() { // O(n)\n    // Returns sorted hours [0,1,2...23]\n    // Find peak engagement time\n  }\n  \n  findPeakHour() { // O(n)\n    let max = 0, peak = 0;\n    this.inOrder(node => {\n      if (node.count > max) {\n        max = node.count;\n        peak = node.hour;\n      }\n    });\n    return peak;\n  }\n}\n```\n\n**Analytics Features:**\n‚Ä¢ Peak activity time detection\n‚Ä¢ Sorted hourly statistics\n‚Ä¢ Range queries (8AM-5PM activity)\n\n**Self-Balancing:** Could use AVL/Red-Black for O(log n) worst case",
    options: ["Tree Traversals", "AVL Trees", "Real Analytics", "Back"]
  },

  "trie": {
    keywords: ["trie", "prefix tree", "autocomplete", "keyword"],
    text: "üéØ **Trie - The Brain Behind This Bot**\n\n**Architecture:**\n```\nclass TrieNode {\n  constructor() {\n    this.children = new Map(); // 26 letters\n    this.isEndOfWord = false;\n    this.knowledgeKey = null;\n    this.weight = 0; // For ranking\n  }\n}\n\nclass EonTrie {\n  insert(word, key, weight) { // O(L)\n    let node = this.root;\n    for (let char of word) {\n      if (!node.children.has(char)) {\n        node.children.set(char, new TrieNode());\n      }\n      node = node.children.get(char);\n    }\n    node.isEndOfWord = true;\n    node.knowledgeKey = key;\n    node.weight = weight;\n  }\n  \n  search(prefix) { // O(L)\n    let node = this.root;\n    for (let char of prefix) {\n      if (!node.children.has(char)) return null;\n      node = node.children.get(char);\n    }\n    return node;\n  }\n  \n  autocomplete(prefix) { // O(L + K)\n    // Returns all words with prefix\n    // Sorted by weight for relevance\n  }\n}\n```\n\n**Use Cases:**\n1. **Keyword Matching:** O(L) vs O(n) linear search\n2. **User Search:** Type \"joh\" ‚Üí find all Johns\n3. **Command Autocomplete:** \"/sta\" ‚Üí \"/status\"\n4. **Spell Check:** Find similar words via DFS\n\n**Space-Time Tradeoff:** O(ALPHABET_SIZE * N) space for O(L) search",
    options: ["Autocomplete Algorithm", "Fuzzy Search", "Back"]
  },

  "graphs": {
    keywords: ["graph", "adjacency", "edge", "node", "vertex", "social"],
    text: "üï∏Ô∏è **Graph - Social Network Backbone**\n\n**Representation:**\n```\nclass SocialGraph {\n  constructor() {\n    // Adjacency List: O(V + E) space\n    this.adjList = new Map();\n  }\n  \n  addUser(userId) { // O(1)\n    if (!this.adjList.has(userId)) {\n      this.adjList.set(userId, new Set());\n    }\n  }\n  \n  addFriendship(user1, user2) { // O(1)\n    this.adjList.get(user1).add(user2);\n    this.adjList.get(user2).add(user1);\n  }\n  \n  getFriends(userId) { // O(1)\n    return this.adjList.get(userId);\n  }\n  \n  removeFriendship(user1, user2) { // O(1)\n    this.adjList.get(user1).delete(user2);\n    this.adjList.get(user2).delete(user1);\n  }\n}\n```\n\n**Properties:**\n‚Ä¢ **Undirected:** Friendship is bidirectional\n‚Ä¢ **Weighted (optional):** Interaction strength\n‚Ä¢ **Dynamic:** Edges change in real-time\n\n**Why Adjacency List?**\n‚Ä¢ Sparse graph (not everyone knows everyone)\n‚Ä¢ O(1) friend check with Set\n‚Ä¢ Memory efficient: O(V + E) vs O(V¬≤) matrix",
    options: ["BFS Algorithm", "DFS Algorithm", "Friend Recommendations", "Back"]
  },

  "hashtables": {
    keywords: ["hashmap", "hash", "dictionary", "table", "o(1)", "cache"],
    text: "‚ö° **HashMap - The Speed Demon**\n\n**EonChat's HashMap Usage:**\n\n**1. Socket Manager:**\n```\nclass SocketManager {\n  constructor() {\n    this.userToSocket = new Map(); // userId ‚Üí socketId\n    this.socketToUser = new Map(); // socketId ‚Üí userId\n  }\n  \n  connect(userId, socketId) { // O(1)\n    this.userToSocket.set(userId, socketId);\n    this.socketToUser.set(socketId, userId);\n  }\n  \n  getSocket(userId) { return this.userToSocket.get(userId); }\n}\n```\n\n**2. Message Cache:**\n```\nclass MessageCache {\n  constructor(maxSize = 1000) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n  \n  get(msgId) { // O(1)\n    return this.cache.get(msgId);\n  }\n  \n  set(msgId, msg) { // O(1)\n    if (this.cache.size >= this.maxSize) {\n      // LRU eviction\n      const first = this.cache.keys().next().value;\n      this.cache.delete(first);\n    }\n    this.cache.set(msgId, msg);\n  }\n}\n```\n\n**3. User Session Store:**\n‚Ä¢ JWT token ‚Üí user data\n‚Ä¢ O(1) authentication lookup\n\n**Hash Function:** MD5/SHA for collision resistance\n**Load Factor:** Resize at 0.75 for performance",
    options: ["Hash Collision Resolution", "LRU Cache", "Back"]
  },

  // ============ ALGORITHMS ============
  "algorithms": {
    keywords: ["algorithm", "bfs", "dfs", "sort", "search"],
    text: "üßÆ **EonChat's Algorithm Suite**\n\n**Graph Algorithms:**\n‚Ä¢ BFS ‚Üí Friend recommendations (Level 2)\n‚Ä¢ DFS ‚Üí Connected components, cycle detection\n‚Ä¢ Dijkstra ‚Üí Shortest path between users\n\n**Sorting:**\n‚Ä¢ QuickSort ‚Üí Message ordering\n‚Ä¢ MergeSort ‚Üí Stable leaderboard sorting\n\n**Search:**\n‚Ä¢ Binary Search ‚Üí Sorted message lookup\n‚Ä¢ Trie Search ‚Üí Keyword matching\n\n**Dynamic Programming:**\n‚Ä¢ Message similarity (edit distance)\n‚Ä¢ Optimal caching strategy\n\n**Greedy:**\n‚Ä¢ Activity selection (scheduling)\n‚Ä¢ Huffman coding (compression)\n\nWhich algorithm?",
    options: ["Graph Algorithms", "Sorting Algorithms", "Search Algorithms", "Advanced Topics"]
  },

  "bfs": {
    keywords: ["bfs", "breadth first", "discovery", "friend recommendations"],
    text: "üåä **BFS - Friend Discovery Algorithm**\n\n**Implementation:**\n```\nclass SocialDiscovery {\n  findFriendsOfFriends(userId, graph) {\n    const queue = [userId];\n    const visited = new Set([userId]);\n    const distances = new Map([[userId, 0]]);\n    const recommendations = [];\n    \n    while (queue.length > 0) {\n      const current = queue.shift();\n      const distance = distances.get(current);\n      \n      // Stop at distance 2\n      if (distance >= 2) continue;\n      \n      for (let friend of graph.getFriends(current)) {\n        if (!visited.has(friend)) {\n          visited.add(friend);\n          queue.push(friend);\n          distances.set(friend, distance + 1);\n          \n          if (distance === 1) {\n            // This is a friend-of-friend\n            recommendations.push({\n              userId: friend,\n              mutualFriends: this.getMutualCount(userId, friend, graph)\n            });\n          }\n        }\n      }\n    }\n    \n    // Sort by mutual friends count\n    return recommendations.sort((a, b) => b.mutualFriends - a.mutualFriends);\n  }\n}\n```\n\n**Complexity:**\n‚Ä¢ Time: O(V + E) where V=users, E=friendships\n‚Ä¢ Space: O(V) for visited set\n\n**Why BFS over DFS?**\n‚Ä¢ Finds closest connections first\n‚Ä¢ Level-order exploration\n‚Ä¢ Better for recommendation systems\n\n**Optimization:** Bidirectional BFS for faster pathfinding",
    options: ["DFS Algorithm", "Shortest Path", "Back"]
  },

  "dfs": {
    keywords: ["dfs", "depth first", "recursive", "backtrack"],
    text: "üèä **DFS - Deep Exploration**\n\n**Implementation:**\n```\nclass GraphAnalyzer {\n  // Find all connected components (friend circles)\n  findCommunities(graph) {\n    const visited = new Set();\n    const communities = [];\n    \n    for (let user of graph.adjList.keys()) {\n      if (!visited.has(user)) {\n        const community = [];\n        this.dfs(user, graph, visited, community);\n        communities.push(community);\n      }\n    }\n    return communities;\n  }\n  \n  dfs(user, graph, visited, community) {\n    visited.add(user);\n    community.push(user);\n    \n    for (let friend of graph.getFriends(user)) {\n      if (!visited.has(friend)) {\n        this.dfs(friend, graph, visited, community);\n      }\n    }\n  }\n  \n  // Detect cycles (problematic friend loops)\n  hasCycle(graph) {\n    const visited = new Set();\n    const recStack = new Set();\n    \n    for (let user of graph.adjList.keys()) {\n      if (this.detectCycle(user, graph, visited, recStack, null)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n```\n\n**Use Cases:**\n1. **Community Detection:** Find friend groups\n2. **Cycle Detection:** Prevent circular dependencies\n3. **Path Existence:** Can user A reach user B?\n4. **Topological Sort:** Message dependencies\n\n**Complexity:** O(V + E)\n**Space:** O(V) recursion stack",
    options: ["BFS vs DFS", "Topological Sort", "Back"]
  },

  "sorting": {
    keywords: ["sort", "quicksort", "mergesort", "order"],
    text: "üìä **Sorting in EonChat**\n\n**1. QuickSort - Message Ordering:**\n```\nfunction sortMessages(messages) {\n  // Pivot: timestamp\n  quickSort(messages, 0, messages.length - 1);\n}\n\n// Average: O(n log n), Worst: O(n¬≤)\n// Space: O(log n) stack\n// In-place, unstable\n```\n\n**2. MergeSort - Leaderboard:**\n```\nfunction sortLeaderboard(users) {\n  // Stable sort by score\n  return mergeSort(users);\n}\n\n// Time: O(n log n) always\n// Space: O(n) auxiliary\n// Stable, consistent\n```\n\n**3. TimSort (JavaScript default):**\n‚Ä¢ Hybrid: Merge + Insertion\n‚Ä¢ Optimized for real-world data\n‚Ä¢ O(n log n) time, O(n) space\n\n**4. Counting Sort - Frequency:**\n```\n// Sort messages by hour (0-23)\nfunction sortByHour(activities) {\n  const count = new Array(24).fill(0);\n  // O(n + k) where k = 24\n}\n```\n\n**When to use which?**\n‚Ä¢ QuickSort: Fast average, memory-constrained\n‚Ä¢ MergeSort: Stable, predictable\n‚Ä¢ CountingSort: Limited range, O(n) possible",
    options: ["Algorithm Comparison", "Custom Sort", "Back"]
  },

  "dynamic_programming": {
    keywords: ["dp", "dynamic", "memoization", "optimization"],
    text: "üéØ **Dynamic Programming in EonChat**\n\n**1. Message Similarity (Edit Distance):**\n```\nfunction editDistance(msg1, msg2) {\n  const m = msg1.length, n = msg2.length;\n  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n  \n  for (let i = 0; i <= m; i++) dp[i][0] = i;\n  for (let j = 0; j <= n; j++) dp[0][j] = j;\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (msg1[i-1] === msg2[j-1]) {\n        dp[i][j] = dp[i-1][j-1];\n      } else {\n        dp[i][j] = 1 + Math.min(\n          dp[i-1][j],    // delete\n          dp[i][j-1],    // insert\n          dp[i-1][j-1]   // replace\n        );\n      }\n    }\n  }\n  return dp[m][n];\n}\n// Time: O(m*n), Space: O(m*n)\n// Use: Detect duplicate messages\n```\n\n**2. Optimal Cache Strategy:**\n```\n// Longest Common Subsequence for chat history\nfunction lcs(messages) {\n  // Find repeated conversation patterns\n  // Cache frequently accessed sequences\n}\n```\n\n**3. Activity Prediction:**\n‚Ä¢ Use past patterns to predict peak times\n‚Ä¢ Fibonacci-like recurrence for trends\n\n**Key Principle:** Overlapping subproblems + Optimal substructure",
    options: ["Memoization vs Tabulation", "Back"]
  },

  // ============ ARCHITECTURE ============
  "architecture": {
    keywords: ["architecture", "system", "design", "flow"],
    text: "üèóÔ∏è **EonChat System Architecture**\n\n**Real-Time Messaging Pipeline:**\n```\nClient ‚Üí WebSocket ‚Üí Server Queue ‚Üí \n  ‚Üì\nValidation ‚Üí Rate Limiter (Token Bucket) ‚Üí \n  ‚Üì\nMessage Handler ‚Üí Graph Update ‚Üí \n  ‚Üì\nBroadcast (HashMap lookup) ‚Üí Recipients\n```\n\n**Data Flow:**\n1. **User Input** ‚Üí Trie validation\n2. **Socket.io** ‚Üí HashMap routing\n3. **MongoDB** ‚Üí B-Tree indexing\n4. **Redis Cache** ‚Üí LRU eviction\n5. **Analytics** ‚Üí BST aggregation\n\n**Scalability:**\n‚Ä¢ Horizontal: Load balancer + sharding\n‚Ä¢ Vertical: Optimize data structures\n‚Ä¢ Caching: Multi-layer (L1: HashMap, L2: Redis)\n\n**Components:**\n‚Ä¢ Graph: Social network\n‚Ä¢ Trie: Search/routing\n‚Ä¢ Heap: Priority queue\n‚Ä¢ HashMap: Everything else",
    options: ["Message Flow", "Caching Strategy", "Scalability", "Back"]
  },

  "message_flow": {
    keywords: ["message", "flow", "pipeline", "delivery"],
    text: "üì® **Message Delivery Architecture**\n\n**Step-by-Step:**\n```\n1. User sends message\n   ‚Üì\n2. WebSocket receives (O(1))\n   ‚Üì\n3. Rate Limiter checks (Token Bucket)\n   - Refill rate: 10 tokens/second\n   - Bucket capacity: 100\n   ‚Üì\n4. Enqueue to Priority Queue (O(log n))\n   - Priority: User role + urgency\n   ‚Üì\n5. Dequeue & Process (O(log n))\n   ‚Üì\n6. Lookup recipients in HashMap (O(1))\n   - userToSocket map\n   ‚Üì\n7. Broadcast via Socket.io (O(k))\n   - k = number of recipients\n   ‚Üì\n8. Store in MongoDB (O(log n))\n   - B-Tree indexing\n   ‚Üì\n9. Update Analytics BST (O(log n))\n   - Hour ‚Üí message count\n   ‚Üì\n10. Cache in Redis (O(1))\n    - LRU eviction policy\n```\n\n**Optimization:**\n‚Ä¢ Batch processing for multiple messages\n‚Ä¢ Compression (Huffman encoding)\n‚Ä¢ CDN for media files\n\n**Failure Handling:**\n‚Ä¢ Message queue persistence\n‚Ä¢ Retry with exponential backoff\n‚Ä¢ Dead letter queue for failed messages",
    options: ["Rate Limiting", "Caching", "Back"]
  },

  "caching": {
    keywords: ["cache", "lru", "redis", "performance"],
    text: "‚ö° **Multi-Layer Caching Strategy**\n\n**L1: In-Memory HashMap (Application Level)**\n```\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map(); // Insertion order preserved\n  }\n  \n  get(key) { // O(1)\n    if (!this.cache.has(key)) return null;\n    \n    // Move to end (most recently used)\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n  \n  put(key, value) { // O(1)\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      // Evict least recently used (first item)\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(key, value);\n  }\n}\n```\n\n**L2: Redis (Distributed Cache)**\n‚Ä¢ Store: Recent messages, user sessions\n‚Ä¢ TTL: 1 hour for messages, 24h for sessions\n‚Ä¢ Pub/Sub: Real-time updates\n\n**L3: CDN (Static Assets)**\n‚Ä¢ Profile pictures, media\n‚Ä¢ Edge caching for low latency\n\n**Cache Invalidation Strategy:**\n1. **Write-Through:** Update cache + DB\n2. **Write-Behind:** Async DB update\n3. **Cache-Aside:** Load on miss\n\n**Eviction Policies:**\n‚Ä¢ LRU: Most common, balanced\n‚Ä¢ LFU: Frequency-based\n‚Ä¢ FIFO: Simple, less optimal",
    options: ["Cache Strategies", "Back"]
  },

  "performance": {
    keywords: ["performance", "complexity", "optimization", "big o"],
    text: "‚ö° **Performance Analysis & Optimization**\n\n**Time Complexity Summary:**\n```\nOperation              | Data Structure | Complexity\n--------------------- | -------------- | ----------\nSocket Lookup         | HashMap        | O(1)\nMessage Send          | Queue          | O(log n)*\nFriend Check          | Graph (Set)    | O(1)\nKeyword Search        | Trie           | O(L)\nActivity Analysis     | BST            | O(log n)\nUser Search           | Trie           | O(L)\nFriend Recommend      | BFS            | O(V + E)\nNotification Pop      | Stack          | O(1)\nMessage Cache         | LRU HashMap    | O(1)\nSort Messages         | QuickSort      | O(n log n)\n\n* Priority Queue (Heap)\nL = length of keyword\nV = vertices (users)\nE = edges (friendships)\n```\n\n**Space Complexity:**\n```\nGraph (Adjacency List): O(V + E)\nTrie: O(ALPHABET_SIZE * N * L)\nBST: O(n)\nHashMap: O(n)\nStack/Queue: O(n)\n```\n\n**Bottleneck Analysis:**\n1. **Database Queries:** Use indexing (B-Tree)\n2. **Network I/O:** Batch requests\n3. **Memory:** LRU cache eviction\n4. **CPU:** Optimize algorithms",
    options: ["Optimization Techniques", "Profiling", "Back to Start"]
  },

  "optimization": {
    keywords: ["optimize", "improve", "faster", "efficient"],
    text: "üöÄ **Optimization Techniques**\n\n**1. Algorithmic:**\n‚Ä¢ Replace O(n¬≤) with O(n log n) or O(n)\n‚Ä¢ Use HashMaps for O(1) lookup\n‚Ä¢ Implement caching (memoization)\n\n**2. Data Structure Selection:**\n‚Ä¢ Trie > Linear Search for keywords\n‚Ä¢ HashMap > Array for frequent lookups\n‚Ä¢ Heap > Sorted Array for priority queues\n\n**3. Database:**\n‚Ä¢ Create indexes on frequently queried fields\n‚Ä¢ Use aggregation pipelines\n‚Ä¢ Denormalize for read-heavy operations\n\n**4. Network:**\n‚Ä¢ WebSocket > HTTP polling\n‚Ä¢ Compress data (gzip, Brotli)\n‚Ä¢ CDN for static assets\n\n**5. Caching:**\n‚Ä¢ Multi-layer (Memory ‚Üí Redis ‚Üí DB)\n‚Ä¢ Cache hot data (80/20 rule)\n‚Ä¢ Implement cache warming\n\n**6. Code-Level:**\n‚Ä¢ Avoid premature optimization\n‚Ä¢ Profile before optimizing\n‚Ä¢ Use lazy evaluation\n‚Ä¢ Implement pagination\n\n**Example: User Search Optimization**\n```\nBefore: O(n) linear scan\nAfter: O(L) Trie search\n\n10,000 users:\nLinear: ~10,000 comparisons\nTrie: ~5 character checks\n\nSpeedup: 2000x!\n```",
    options: ["Profiling Tools", "Back"]
  },

  // ============ ADVANCED TOPICS ============
  "advanced": {
    keywords: ["advanced", "expert", "deep", "complex"],
    text: "üéì **Advanced DSA Topics in EonChat**\n\n**1. Self-Balancing Trees:**\n‚Ä¢ AVL Tree for guaranteed O(log n)\n‚Ä¢ Red-Black Tree (less strict, faster)\n\n**2. Bloom Filters:**\n‚Ä¢ Probabilistic membership test\n‚Ä¢ Check if user exists: O(k) with space savings\n‚Ä¢ Use: Blacklist filtering\n\n**3. Skip Lists:**\n‚Ä¢ Alternative to balanced trees\n‚Ä¢ Multiple levels of linked lists\n‚Ä¢ Expected O(log n) operations\n\n**4. Segment Trees:**\n‚Ä¢ Range query optimization\n‚Ä¢ Find most active time range\n‚Ä¢ O(log n) query, O(n) space\n\n**5. Consistent Hashing:**\n‚Ä¢ Distributed systems\n‚Ä¢ Minimal data movement on node addition\n‚Ä¢ Ring-based distribution\n\n**6. Union-Find (Disjoint Set):**\n‚Ä¢ Track connected components efficiently\n‚Ä¢ Path compression + union by rank\n‚Ä¢ Nearly O(1) amortized operations",
    options: ["AVL Trees", "Bloom Filters", "Consistent Hashing", "Back"]
  },

  "avl_trees": {
    keywords: ["avl", "balanced", "rotation", "self-balancing"],
    text: "‚öñÔ∏è **AVL Trees - Perfect Balance**\n\n**Structure:**\n```\nclass AVLNode {\n  constructor(hour, count) {\n    this.hour = hour;\n    this.count = count;\n    this.height = 1;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass AVLTree {\n  getHeight(node) {\n    return node ? node.height : 0;\n  }\n  \n  getBalance(node) {\n    return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0;\n  }\n  \n  rotateRight(y) { // O(1)\n    const x = y.left;\n    const T2 = x.right;\n    \n    x.right = y;\n    y.left = T2;\n    \n    y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;\n    x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;\n    \n    return x;\n  }\n  \n  rotateLeft(x) { // O(1)\n    const y = x.right;\n    const T2 = y.left;\n    \n    y.left = x;\n    x.right = T2;\n    \n    x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;\n    y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;\n    \n    return y;\n  }\n  \n  insert(node, hour, count) { // O(log n) GUARANTEED\n    // Standard BST insert\n    if (!node) return new AVLNode(hour, count);\n    \n    if (hour < node.hour) {\n      node.left = this.insert(node.left, hour, count);\n    } else if (hour > node.hour) {\n      node.right = this.insert(node.right, hour, count);\n    } else {\n      node.count += count;\n      return node;\n    }\n    \n    // Update height\n    node.height = Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1;\n    \n    // Check balance\n    const balance = this.getBalance(node);\n    \n    // Left-Left Case\n    if (balance > 1 && hour < node.left.hour) {\n      return this.rotateRight(node);\n    }\n    \n    // Right-Right Case\n    if (balance < -1 && hour > node.right.hour) {\n      return this.rotateLeft(node);\n    }\n    \n    // Left-Right Case\n    if (balance > 1 && hour > node.left.hour) {\n      node.left = this.rotateLeft(node.left);\n      return this.rotateRight(node);\n    }\n    \n    // Right-Left Case\n    if (balance < -1 && hour < node.right.hour) {\n      node.right = this.rotateRight(node.right);\n      return this.rotateLeft(node);\n    }\n    \n    return node;\n  }\n}\n```\n\n**Why AVL for EonChat Analytics?**\n‚Ä¢ **Guaranteed O(log n)** for all operations\n‚Ä¢ Heavy read workload (analytics queries)\n‚Ä¢ Height difference ‚â§ 1 ensures perfect balance\n\n**Trade-offs:**\n‚Ä¢ More rotations than Red-Black trees\n‚Ä¢ Better for read-heavy workloads\n‚Ä¢ Stricter balancing = slower inserts",
    options: ["Red-Black Trees", "BST Comparison", "Back"]
  },

  "bloom_filters": {
    keywords: ["bloom", "filter", "probabilistic", "membership"],
    text: "üå∏ **Bloom Filters - Space-Efficient Membership**\n\n**Architecture:**\n```\nclass BloomFilter {\n  constructor(size, numHashes) {\n    this.size = size;\n    this.numHashes = numHashes;\n    this.bitArray = new Array(size).fill(0);\n  }\n  \n  hash(item, seed) {\n    let hash = 0;\n    const str = item + seed;\n    for (let i = 0; i < str.length; i++) {\n      hash = ((hash << 5) - hash) + str.charCodeAt(i);\n      hash = hash & hash; // Convert to 32-bit int\n    }\n    return Math.abs(hash) % this.size;\n  }\n  \n  add(userId) { // O(k) where k = numHashes\n    for (let i = 0; i < this.numHashes; i++) {\n      const index = this.hash(userId, i);\n      this.bitArray[index] = 1;\n    }\n  }\n  \n  contains(userId) { // O(k)\n    for (let i = 0; i < this.numHashes; i++) {\n      const index = this.hash(userId, i);\n      if (this.bitArray[index] === 0) {\n        return false; // Definitely NOT in set\n      }\n    }\n    return true; // PROBABLY in set\n  }\n}\n```\n\n**EonChat Use Cases:**\n\n**1. Blocked Users Filter:**\n```\nconst blockedUsers = new BloomFilter(10000, 3);\n\n// Add blocked users\nblockedUsers.add('user123');\nblockedUsers.add('spammer456');\n\n// Fast check before message delivery\nif (blockedUsers.contains(recipientId)) {\n  // Might be blocked, check DB for confirmation\n  const isBlocked = await db.isUserBlocked(recipientId);\n  if (isBlocked) return;\n}\n```\n\n**2. Duplicate Message Detection:**\n‚Ä¢ Store message hashes\n‚Ä¢ Quick check: \"Have we seen this before?\"\n‚Ä¢ Space: 1 bit per hash vs full message storage\n\n**Properties:**\n‚Ä¢ **False Positives:** Possible (\"maybe in set\")\n‚Ä¢ **False Negatives:** NEVER (\"definitely not in set\")\n‚Ä¢ **Space:** ~10 bits per element (vs 64+ for HashMap)\n‚Ä¢ **Time:** O(k) where k = number of hash functions\n\n**Optimal Parameters:**\n```\nn = expected elements\np = false positive rate (e.g., 0.01 = 1%)\n\nm (bits) = -n * ln(p) / (ln(2)¬≤)\nk (hashes) = (m/n) * ln(2)\n\nExample: 10,000 users, 1% FP rate\nm = 95,851 bits (~12 KB)\nk = 7 hash functions\n```",
    options: ["Counting Bloom Filters", "Back"]
  },

  "consistent_hashing": {
    keywords: ["consistent", "hashing", "distributed", "ring", "sharding"],
    text: "üîÑ **Consistent Hashing - Distributed Architecture**\n\n**Architecture:**\n```\nclass ConsistentHash {\n  constructor(virtualNodes = 150) {\n    this.virtualNodes = virtualNodes;\n    this.ring = new Map(); // Sorted positions\n    this.nodes = new Set();\n  }\n  \n  hash(key) {\n    // Simple hash function (use better in production)\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash = ((hash << 5) - hash) + key.charCodeAt(i);\n    }\n    return Math.abs(hash);\n  }\n  \n  addNode(nodeId) { // O(V log V) where V = virtualNodes\n    this.nodes.add(nodeId);\n    \n    // Add virtual nodes for better distribution\n    for (let i = 0; i < this.virtualNodes; i++) {\n      const virtualKey = `${nodeId}:${i}`;\n      const position = this.hash(virtualKey);\n      this.ring.set(position, nodeId);\n    }\n    \n    // Sort ring by position\n    this.ring = new Map([...this.ring.entries()].sort((a, b) => a[0] - b[0]));\n  }\n  \n  removeNode(nodeId) { // O(V log V)\n    this.nodes.delete(nodeId);\n    \n    // Remove all virtual nodes\n    for (let i = 0; i < this.virtualNodes; i++) {\n      const virtualKey = `${nodeId}:${i}`;\n      const position = this.hash(virtualKey);\n      this.ring.delete(position);\n    }\n  }\n  \n  getNode(key) { // O(log V)\n    if (this.ring.size === 0) return null;\n    \n    const position = this.hash(key);\n    \n    // Find first node clockwise from position\n    for (let [ringPos, nodeId] of this.ring.entries()) {\n      if (ringPos >= position) {\n        return nodeId;\n      }\n    }\n    \n    // Wrap around to first node\n    return this.ring.values().next().value;\n  }\n}\n```\n\n**EonChat Use Cases:**\n\n**1. WebSocket Server Distribution:**\n```\nconst hashRing = new ConsistentHash();\n\n// Add servers\nhashRing.addNode('server-1');\nhashRing.addNode('server-2');\nhashRing.addNode('server-3');\n\n// Route user to server\nconst server = hashRing.getNode(userId);\nconnectToServer(server, userId);\n\n// When server-2 fails:\nhashRing.removeNode('server-2');\n// Only ~33% of users are remapped (not 50%!)\n```\n\n**2. Cache Sharding:**\n‚Ä¢ Distribute user sessions across Redis instances\n‚Ä¢ Minimal reorganization on scale-up/down\n\n**Why Consistent Hashing?**\n\n**Traditional Hashing:**\n```\nserverIndex = hash(userId) % numServers\n\nAdd server: 3 ‚Üí 4 servers\n75% of data needs remapping! üí•\n```\n\n**Consistent Hashing:**\n```\nAdd server: Only K/N keys remapped\nwhere K = total keys, N = new server count\n\n~25% remapping for 3 ‚Üí 4 servers ‚úÖ\n```\n\n**Virtual Nodes Benefits:**\n‚Ä¢ Even distribution (prevents hotspots)\n‚Ä¢ More virtual nodes = better balance\n‚Ä¢ Trade-off: Memory for distribution quality",
    options: ["Rendezvous Hashing", "Back"]
  },

  "union_find": {
    keywords: ["union", "find", "disjoint", "connected", "components"],
    text: "üîó **Union-Find - Connected Components**\n\n**Optimized Implementation:**\n```\nclass UnionFind {\n  constructor(size) {\n    this.parent = Array.from({length: size}, (_, i) => i);\n    this.rank = new Array(size).fill(0);\n    this.componentCount = size;\n  }\n  \n  find(x) { // O(Œ±(n)) ‚âà O(1) with path compression\n    if (this.parent[x] !== x) {\n      // Path compression: point directly to root\n      this.parent[x] = this.find(this.parent[x]);\n    }\n    return this.parent[x];\n  }\n  \n  union(x, y) { // O(Œ±(n)) ‚âà O(1)\n    const rootX = this.find(x);\n    const rootY = this.find(y);\n    \n    if (rootX === rootY) return false; // Already connected\n    \n    // Union by rank: attach smaller tree to larger\n    if (this.rank[rootX] < this.rank[rootY]) {\n      this.parent[rootX] = rootY;\n    } else if (this.rank[rootX] > this.rank[rootY]) {\n      this.parent[rootY] = rootX;\n    } else {\n      this.parent[rootY] = rootX;\n      this.rank[rootX]++;\n    }\n    \n    this.componentCount--;\n    return true;\n  }\n  \n  connected(x, y) { // O(Œ±(n))\n    return this.find(x) === this.find(y);\n  }\n  \n  getComponentCount() { // O(1)\n    return this.componentCount;\n  }\n}\n```\n\n**EonChat Applications:**\n\n**1. Friend Circles Detection:**\n```\nfunction findFriendCircles(users, friendships) {\n  const uf = new UnionFind(users.length);\n  const userIndex = new Map();\n  \n  users.forEach((user, idx) => userIndex.set(user, idx));\n  \n  // Union all friendships\n  for (let [user1, user2] of friendships) {\n    uf.union(userIndex.get(user1), userIndex.get(user2));\n  }\n  \n  // Group users by root parent\n  const circles = new Map();\n  for (let i = 0; i < users.length; i++) {\n    const root = uf.find(i);\n    if (!circles.has(root)) circles.set(root, []);\n    circles.get(root).push(users[i]);\n  }\n  \n  return Array.from(circles.values());\n}\n```\n\n**2. Network Connectivity:**\n‚Ä¢ Track if users are in same friend network\n‚Ä¢ Check: \"Can message reach user B from user A?\"\n‚Ä¢ O(1) query after initial setup\n\n**3. Group Chat Merging:**\n‚Ä¢ Merge overlapping group chats\n‚Ä¢ Find all interconnected groups\n\n**Complexity Analysis:**\n‚Ä¢ **Time:** O(Œ±(n)) per operation\n  - Œ±(n) = inverse Ackermann function\n  - Grows EXTREMELY slowly (Œ±(10‚Å∏‚Å∞) ‚âà 4)\n  - Effectively O(1) for all practical purposes\n‚Ä¢ **Space:** O(n) for parent and rank arrays\n\n**Optimizations:**\n1. **Path Compression:** Makes tree flat\n2. **Union by Rank:** Keeps tree balanced\n3. **Together:** Nearly constant time!",
    options: ["Graph Algorithms", "Back"]
  },

  // Add missing navigation nodes
  "graph_algorithms": {
    keywords: ["graph algorithm", "traversal", "pathfinding"],
    text: "üó∫Ô∏è **Graph Algorithms Suite**\n\n**Traversal:**\n‚Ä¢ BFS - Level-order, shortest path (unweighted)\n‚Ä¢ DFS - Explore depth, cycle detection\n‚Ä¢ Iterative Deepening - Memory-efficient DFS\n\n**Shortest Path:**\n‚Ä¢ Dijkstra - Weighted graphs (positive)\n‚Ä¢ Bellman-Ford - Negative weights allowed\n‚Ä¢ A* - Heuristic-guided (fastest)\n\n**Minimum Spanning Tree:**\n‚Ä¢ Kruskal's - Edge-based, uses Union-Find\n‚Ä¢ Prim's - Vertex-based, uses Min-Heap\n\n**Network Flow:**\n‚Ä¢ Ford-Fulkerson - Maximum flow\n‚Ä¢ Useful for: Message routing, load balancing\n\n**Community Detection:**\n‚Ä¢ Louvain Algorithm - Modularity optimization\n‚Ä¢ Label Propagation - Fast clustering",
    options: ["BFS Algorithm", "Dijkstra's Algorithm", "Back"]
  },

  "dijkstra": {
    keywords: ["dijkstra", "shortest path", "weighted"],
    text: "üéØ **Dijkstra's Algorithm - Shortest Path**\n\n**Implementation:**\n```\nclass PriorityQueue {\n  // Min-heap implementation\n  enqueue(node, priority) { /* ... */ }\n  dequeue() { /* ... */ }\n}\n\nfunction dijkstra(graph, start, end) {\n  const distances = new Map();\n  const previous = new Map();\n  const pq = new PriorityQueue();\n  \n  // Initialize\n  for (let node of graph.nodes) {\n    distances.set(node, Infinity);\n  }\n  distances.set(start, 0);\n  pq.enqueue(start, 0);\n  \n  while (!pq.isEmpty()) {\n    const current = pq.dequeue();\n    \n    if (current === end) break; // Found shortest path\n    \n    for (let neighbor of graph.getNeighbors(current)) {\n      const weight = graph.getEdgeWeight(current, neighbor);\n      const newDist = distances.get(current) + weight;\n      \n      if (newDist < distances.get(neighbor)) {\n        distances.set(neighbor, newDist);\n        previous.set(neighbor, current);\n        pq.enqueue(neighbor, newDist);\n      }\n    }\n  }\n  \n  // Reconstruct path\n  const path = [];\n  let current = end;\n  while (current !== start) {\n    path.unshift(current);\n    current = previous.get(current);\n  }\n  path.unshift(start);\n  \n  return { distance: distances.get(end), path };\n}\n```\n\n**EonChat Use Case:**\n‚Ä¢ **Weighted Social Graph:** Edge weight = interaction strength\n‚Ä¢ Find \"closest\" users by relationship strength\n‚Ä¢ Recommend strongest connection paths\n\n**Complexity:**\n‚Ä¢ Time: O((V + E) log V) with binary heap\n‚Ä¢ Space: O(V) for distances/previous\n\n**Optimization:** Use Fibonacci heap for O(E + V log V)",
    options: ["A* Algorithm", "Back"]
  },

  "search_algorithms": {
    keywords: ["search algorithm", "binary", "linear"],
    text: "üîç **Search Algorithms in EonChat**\n\n**1. Binary Search - Sorted Messages:**\n```\nfunction binarySearchMessage(messages, targetTime) {\n  let left = 0, right = messages.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (messages[mid].timestamp === targetTime) {\n      return mid;\n    } else if (messages[mid].timestamp < targetTime) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return -1; // Not found\n}\n// O(log n) - requires sorted array\n```\n\n**2. Trie-Based Search - User Lookup:**\n‚Ä¢ Already implemented in this bot!\n‚Ä¢ O(L) where L = search term length\n\n**3. Fuzzy Search - Autocorrect:**\n```\nfunction fuzzySearch(query, dictionary, maxDistance = 2) {\n  const results = [];\n  \n  for (let word of dictionary) {\n    const distance = levenshteinDistance(query, word);\n    if (distance <= maxDistance) {\n      results.push({ word, distance });\n    }\n  }\n  \n  return results.sort((a, b) => a.distance - b.distance);\n}\n```\n\n**4. KMP String Matching:**\n‚Ä¢ Find substring in message history\n‚Ä¢ O(n + m) vs O(n*m) naive approach",
    options: ["Binary Search Trees", "Trie Deep Dive", "Back"]
  }
}